[Skip to content](https://github.com/mco-gh/bg/blob/main/BE_prompt.md#start-of-content)

You signed in with another tab or window. [Reload](https://github.com/mco-gh/bg/blob/main/BE_prompt.md) to refresh your session.You signed out in another tab or window. [Reload](https://github.com/mco-gh/bg/blob/main/BE_prompt.md) to refresh your session.You switched accounts on another tab or window. [Reload](https://github.com/mco-gh/bg/blob/main/BE_prompt.md) to refresh your session.Dismiss alert

{{ message }}

[mco-gh](https://github.com/mco-gh)/ **[bg](https://github.com/mco-gh/bg)** Public

generated from [google-gemini/aistudio-repository-template](https://github.com/google-gemini/aistudio-repository-template)

- [Notifications](https://github.com/login?return_to=%2Fmco-gh%2Fbg) You must be signed in to change notification settings
- [Fork\\
0](https://github.com/login?return_to=%2Fmco-gh%2Fbg)
- [Star\\
0](https://github.com/login?return_to=%2Fmco-gh%2Fbg)


## Collapse file tree

## Files

main

Search this repository

/

# BE\_prompt.md

Copy path

BlameMore file actions

BlameMore file actions

## Latest commit

[![mco-gh](https://avatars.githubusercontent.com/u/658327?v=4&size=40)](https://github.com/mco-gh)[mco-gh](https://github.com/mco-gh/bg/commits?author=mco-gh)

[feat: Integrate game hosting and joining into main game page](https://github.com/mco-gh/bg/commit/c41fea7fca668fa0871e466768e3a1149f184671)

Open commit detailssuccess

1 minute agoNov 17, 2025

[c41fea7](https://github.com/mco-gh/bg/commit/c41fea7fca668fa0871e466768e3a1149f184671) · 1 minute agoNov 17, 2025

## History

[History](https://github.com/mco-gh/bg/commits/main/BE_prompt.md)

Open commit details

[View commit history for this file.](https://github.com/mco-gh/bg/commits/main/BE_prompt.md)

117 lines (96 loc) · 6.01 KB

/

# BE\_prompt.md

Top

## File metadata and controls

- Preview

- Code

- Blame


117 lines (96 loc) · 6.01 KB

[Raw](https://github.com/mco-gh/bg/raw/refs/heads/main/BE_prompt.md)

Copy raw file

Download raw file

Edit and raw actions

**ROLE:** Act as a world-class senior backend engineer specializing in real-time applications and game development.

**GOAL:** Create a backend service for a two-player online backgammon game. The backend will manage game state, player connections, and real-time updates between the two clients.

**CONTEXT:**
The frontend is a React/TypeScript application. The core game state is represented by an array of 24 `PointState` objects. A player makes a move by dragging a checker from a starting point to a destination point.

The frontend uses the following data structures, which should be mirrored in Python (e.g., using Dictionaries or TypedDicts):

```
type Player = 'white' | 'black';

interface PointState {
  checkers: number;
  player: Player | null;
}

// The entire board is represented as:
// type BoardState = PointState[];
// In Python, this would be a List[Dict[str, Union[int, str, None]]].
```

**TECHNOLOGY STACK:**
Please use the following stack:

- **Language:** Python
- **Framework:** Flask
- **Real-time Communication:** WebSocket API using the `Flask-SocketIO` library.

**CORE REQUIREMENTS & API DESIGN:**

Design a WebSocket-based API that handles the entire game lifecycle. The server must be the single source of truth for the game state to prevent cheating and desynchronization. Use Socket.IO rooms to manage game sessions.

Please implement the following Socket.IO event handlers and logic:

**1\. Game Creation & Connection**

- **`create-game` (Client -> Server)**
  - **Payload:**`{}`
  - **Action:** When a player opens the app, the client sends this event.
  - **Server Response:**
    1. Generate a unique, human-readable Game ID (e.g., `ABC-DEF-GHI`).
    2. Create a new game session in memory, associated with that Game ID. The session should store the `boardState`, the current `turn`, and the session IDs (SIDs) of both players.
    3. The first player is "Player 1".
    4. Have the player join a Socket.IO room named after the Game ID.
    5. Emit a `game-created` event back to the requesting client.
  - **`game-created` (Server -> Client)**
    - **Payload:**`{ "gameId": "some-unique-id" }`
- **`join-game` (Client -> Server)**
  - **Payload:**`{ "gameId": "some-unique-id" }`
  - **Action:** When a second player tries to connect using a Game ID.
  - **Server Response:**
    1. Validate the `gameId`.
    2. If the game exists and its room has only one player, add the second player ("Player 2") to the session and the room.
    3. If the game is full or the ID is invalid, emit an `error` event back to the joining client.
    4. If successful, emit a `game-started` event to **all clients in the room**.
  - **`game-started` (Server -> Both Clients in Room)**
    - **Payload:**`{ "boardState": List[PointState], "turn": "white", "players": { "white": "player1_sid", "black": "player2_sid" } }`
    - This message signals that both players are connected and the game can begin. The server decides which player ID gets which color.

**2\. Gameplay Logic**

- **`roll-dice` (Client -> Server)**
  - **Payload:**`{ "gameId": "some-unique-id" }`
  - **Action:** Sent by the player whose turn it is.
  - **Server Response:**
    1. Verify it is the correct player's turn by checking their SID.
    2. Generate two random numbers from 1 to 6.
    3. Store the dice values in the game session.
    4. Emit a `dice-rolled` event to **all clients in the room**.
  - **`dice-rolled` (Server -> Both Clients in Room)**
    - **Payload:**`{ "dice": [number, number], "turn": Player }`
- **`move-piece` (Client -> Server)**
  - **Payload:**`{ "gameId": "some-unique-id", "fromPointIndex": number, "toPointIndex": number }`
  - **Action:** Sent when a player completes a drag-and-drop move.
  - **Server Response:**
    1. Validate the move:
       - Is it the correct player's turn?
       - Is the move legal according to the rules of backgammon and the current dice roll?
    2. If the move is invalid, emit an `error` event to the moving player.
    3. If the move is valid:
       - Update the `boardState` on the server.
       - Update the remaining dice moves available.
       - Emit a `board-updated` event to **all clients in the room**.
  - **`board-updated` (Server -> Both Clients in Room)**
    - **Payload:**`{ "boardState": List[PointState] }`
- **`end-turn` (Client -> Server)**
  - **Payload:**`{ "gameId": "some-unique-id" }`
  - **Action:** Sent by a player when they have completed all their moves.
  - **Server Response:**
    1. Verify the player has used their dice moves correctly.
    2. Switch the `turn` to the other player.
    3. Emit a `new-turn` event to **all clients in the room**.
  - **`new-turn` (Server -> Both Clients in Room)**
    - **Payload:**`{ "turn": Player }`

**3\. Other Essential Features**

- **Connection Handling:**
  - Use Socket.IO's built-in `disconnect` event handler.
  - If a player disconnects, notify the other player in the room with a `player-disconnected` event.
- **Error Handling:**
  - Implement a generic `error` event for invalid actions.
  - **`error` (Server -> Client)**
    - **Payload:**`{ "message": "Some error message" }`
    - **Examples:** "Invalid move", "Not your turn", "Game not found".

**FINAL OUTPUT:**
Please provide the complete, runnable backend code. The code should be well-structured, commented, and include:

1. An `app.py` file that sets up the Flask server and Flask-SocketIO instance.
2. Clear logic for managing game sessions (an in-memory dictionary is fine for this scope).
3. All the Socket.IO event handlers described above.
4. A `requirements.txt` file listing all necessary dependencies (e.g., `Flask`, `Flask-SocketIO`, `python-dotenv`).
5. A `README.md` explaining how to set up a virtual environment, install dependencies (`pip install -r requirements.txt`), and run the server (`python app.py`).

You can’t perform that action at this time.